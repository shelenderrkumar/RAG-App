"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@langchain+langgraph-sdk@0.0.8";
exports.ids = ["vendor-chunks/@langchain+langgraph-sdk@0.0.8"];
exports.modules = {

/***/ "(ssr)/../node_modules/.pnpm/@langchain+langgraph-sdk@0.0.8/node_modules/@langchain/langgraph-sdk/dist/client.mjs":
/*!******************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@langchain+langgraph-sdk@0.0.8/node_modules/@langchain/langgraph-sdk/dist/client.mjs ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AssistantsClient: () => (/* binding */ AssistantsClient),\n/* harmony export */   Client: () => (/* binding */ Client),\n/* harmony export */   CronsClient: () => (/* binding */ CronsClient),\n/* harmony export */   RunsClient: () => (/* binding */ RunsClient),\n/* harmony export */   ThreadsClient: () => (/* binding */ ThreadsClient)\n/* harmony export */ });\n/* harmony import */ var _utils_async_caller_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/async_caller.mjs */ \"(ssr)/../node_modules/.pnpm/@langchain+langgraph-sdk@0.0.8/node_modules/@langchain/langgraph-sdk/dist/utils/async_caller.mjs\");\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! eventsource-parser */ \"(ssr)/../node_modules/.pnpm/eventsource-parser@1.1.2/node_modules/eventsource-parser/dist/index.js\");\n/* harmony import */ var _utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/stream.mjs */ \"(ssr)/../node_modules/.pnpm/@langchain+langgraph-sdk@0.0.8/node_modules/@langchain/langgraph-sdk/dist/utils/stream.mjs\");\n\n\n\nclass BaseClient {\n    constructor(config) {\n        Object.defineProperty(this, \"asyncCaller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeoutMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"defaultHeaders\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.asyncCaller = new _utils_async_caller_mjs__WEBPACK_IMPORTED_MODULE_0__.AsyncCaller({\n            maxRetries: 4,\n            maxConcurrency: 4,\n            ...config?.callerOptions,\n        });\n        this.timeoutMs = config?.timeoutMs || 12_000;\n        this.apiUrl = config?.apiUrl || \"http://localhost:8123\";\n        this.defaultHeaders = config?.defaultHeaders || {};\n        if (config?.apiKey != null) {\n            this.defaultHeaders[\"X-Api-Key\"] = config.apiKey;\n        }\n    }\n    prepareFetchOptions(path, options) {\n        const mutatedOptions = {\n            ...options,\n            headers: { ...this.defaultHeaders, ...options?.headers },\n        };\n        if (mutatedOptions.json) {\n            mutatedOptions.body = JSON.stringify(mutatedOptions.json);\n            mutatedOptions.headers = {\n                ...mutatedOptions.headers,\n                \"Content-Type\": \"application/json\",\n            };\n            delete mutatedOptions.json;\n        }\n        const targetUrl = new URL(`${this.apiUrl}${path}`);\n        if (mutatedOptions.params) {\n            for (const [key, value] of Object.entries(mutatedOptions.params)) {\n                if (value == null)\n                    continue;\n                let strValue = typeof value === \"string\" || typeof value === \"number\"\n                    ? value.toString()\n                    : JSON.stringify(value);\n                targetUrl.searchParams.append(key, strValue);\n            }\n            delete mutatedOptions.params;\n        }\n        return [targetUrl, mutatedOptions];\n    }\n    async fetch(path, options) {\n        const response = await this.asyncCaller.fetch(...this.prepareFetchOptions(path, options));\n        if (response.status === 202 || response.status === 204) {\n            return undefined;\n        }\n        return response.json();\n    }\n}\nclass CronsClient extends BaseClient {\n    /**\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this cron job.\n     * @param payload Payload for creating a cron job.\n     * @returns The created background run.\n     */\n    async createForThread(threadId, assistantId, payload) {\n        const json = {\n            schedule: payload?.schedule,\n            input: payload?.input,\n            config: payload?.config,\n            metadata: payload?.metadata,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            webhook: payload?.webhook,\n        };\n        return this.fetch(`/threads/${threadId}/runs/crons`, {\n            method: \"POST\",\n            json,\n        });\n    }\n    /**\n     *\n     * @param assistantId Assistant ID to use for this cron job.\n     * @param payload Payload for creating a cron job.\n     * @returns\n     */\n    async create(assistantId, payload) {\n        const json = {\n            schedule: payload?.schedule,\n            input: payload?.input,\n            config: payload?.config,\n            metadata: payload?.metadata,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            webhook: payload?.webhook,\n        };\n        return this.fetch(`/runs/crons`, {\n            method: \"POST\",\n            json,\n        });\n    }\n    /**\n     *\n     * @param cronId Cron ID of Cron job to delete.\n     */\n    async delete(cronId) {\n        await this.fetch(`/runs/crons/${cronId}`, {\n            method: \"DELETE\",\n        });\n    }\n    /**\n     *\n     * @param query Query options.\n     * @returns List of crons.\n     */\n    async search(query) {\n        return this.fetch(\"/runs/crons/search\", {\n            method: \"POST\",\n            json: {\n                assistant_id: query?.assistantId ?? undefined,\n                thread_id: query?.threadId ?? undefined,\n                limit: query?.limit ?? 10,\n                offset: query?.offset ?? 0,\n            },\n        });\n    }\n}\nclass AssistantsClient extends BaseClient {\n    /**\n     * Get an assistant by ID.\n     *\n     * @param assistantId The ID of the assistant.\n     * @returns Assistant\n     */\n    async get(assistantId) {\n        return this.fetch(`/assistants/${assistantId}`);\n    }\n    /**\n     * Get the JSON representation of the graph assigned to a runnable\n     * @param assistantId The ID of the assistant.\n     * @returns Serialized graph\n     */\n    async getGraph(assistantId) {\n        return this.fetch(`/assistants/${assistantId}/graph`);\n    }\n    /**\n     * Get the state and config schema of the graph assigned to a runnable\n     * @param assistantId The ID of the assistant.\n     * @returns Graph schema\n     */\n    async getSchemas(assistantId) {\n        return this.fetch(`/assistants/${assistantId}/schemas`);\n    }\n    /**\n     * Create a new assistant.\n     * @param payload Payload for creating an assistant.\n     * @returns The created assistant.\n     */\n    async create(payload) {\n        return this.fetch(\"/assistants\", {\n            method: \"POST\",\n            json: {\n                graph_id: payload.graphId,\n                config: payload.config,\n                metadata: payload.metadata,\n            },\n        });\n    }\n    /**\n     * Update an assistant.\n     * @param assistantId ID of the assistant.\n     * @param payload Payload for updating the assistant.\n     * @returns The updated assistant.\n     */\n    async update(assistantId, payload) {\n        return this.fetch(`/assistants/${assistantId}`, {\n            method: \"PATCH\",\n            json: {\n                graph_id: payload.graphId,\n                config: payload.config,\n                metadata: payload.metadata,\n            },\n        });\n    }\n    /**\n     * Delete an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     */\n    async delete(assistantId) {\n        return this.fetch(`/assistants/${assistantId}`, {\n            method: \"DELETE\",\n        });\n    }\n    /**\n     * List assistants.\n     * @param query Query options.\n     * @returns List of assistants.\n     */\n    async search(query) {\n        return this.fetch(\"/assistants/search\", {\n            method: \"POST\",\n            json: {\n                graph_id: query?.graphId ?? undefined,\n                metadata: query?.metadata ?? undefined,\n                limit: query?.limit ?? 10,\n                offset: query?.offset ?? 0,\n            },\n        });\n    }\n}\nclass ThreadsClient extends BaseClient {\n    /**\n     * Get a thread by ID.\n     *\n     * @param threadId ID of the thread.\n     * @returns The thread.\n     */\n    async get(threadId) {\n        return this.fetch(`/threads/${threadId}`);\n    }\n    /**\n     * Create a new thread.\n     *\n     * @param payload Payload for creating a thread.\n     * @returns The created thread.\n     */\n    async create(payload) {\n        return this.fetch(`/threads`, {\n            method: \"POST\",\n            json: {\n                metadata: payload?.metadata,\n                thread_id: payload?.threadId,\n                if_exists: payload?.ifExists,\n            },\n        });\n    }\n    /**\n     * Copy an existing thread\n     * @param threadId ID of the thread to be copied\n     * @returns Newly copied thread\n     */\n    async copy(threadId) {\n        return this.fetch(`/threads/${threadId}/copy`, {\n            method: \"POST\",\n        });\n    }\n    /**\n     * Update a thread.\n     *\n     * @param threadId ID of the thread.\n     * @param payload Payload for updating the thread.\n     * @returns The updated thread.\n     */\n    async update(threadId, payload) {\n        return this.fetch(`/threads/${threadId}`, {\n            method: \"PATCH\",\n            json: { metadata: payload?.metadata },\n        });\n    }\n    /**\n     * Delete a thread.\n     *\n     * @param threadId ID of the thread.\n     */\n    async delete(threadId) {\n        return this.fetch(`/threads/${threadId}`, {\n            method: \"DELETE\",\n        });\n    }\n    /**\n     * List threads\n     *\n     * @param query Query options\n     * @returns List of threads\n     */\n    async search(query) {\n        return this.fetch(\"/threads/search\", {\n            method: \"POST\",\n            json: {\n                metadata: query?.metadata ?? undefined,\n                limit: query?.limit ?? 10,\n                offset: query?.offset ?? 0,\n            },\n        });\n    }\n    /**\n     * Get state for a thread.\n     *\n     * @param threadId ID of the thread.\n     * @returns Thread state.\n     */\n    async getState(threadId, checkpointId) {\n        return this.fetch(checkpointId != null\n            ? `/threads/${threadId}/state/${checkpointId}`\n            : `/threads/${threadId}/state`);\n    }\n    /**\n     * Add state to a thread.\n     *\n     * @param threadId The ID of the thread.\n     * @returns\n     */\n    async updateState(threadId, options) {\n        return this.fetch(`/threads/${threadId}/state`, {\n            method: \"POST\",\n            json: {\n                values: options.values,\n                checkpoint_id: options.checkpointId,\n                as_node: options?.asNode,\n            },\n        });\n    }\n    /**\n     * Patch the metadata of a thread.\n     *\n     * @param threadIdOrConfig Thread ID or config to patch the state of.\n     * @param metadata Metadata to patch the state with.\n     */\n    async patchState(threadIdOrConfig, metadata) {\n        let threadId;\n        if (typeof threadIdOrConfig !== \"string\") {\n            if (typeof threadIdOrConfig.configurable.thread_id !== \"string\") {\n                throw new Error(\"Thread ID is required when updating state with a config.\");\n            }\n            threadId = threadIdOrConfig.configurable.thread_id;\n        }\n        else {\n            threadId = threadIdOrConfig;\n        }\n        return this.fetch(`/threads/${threadId}/state`, {\n            method: \"PATCH\",\n            json: { metadata: metadata },\n        });\n    }\n    /**\n     * Get all past states for a thread.\n     *\n     * @param threadId ID of the thread.\n     * @param options Additional options.\n     * @returns List of thread states.\n     */\n    async getHistory(threadId, options) {\n        return this.fetch(`/threads/${threadId}/history`, {\n            method: \"POST\",\n            json: {\n                limit: options?.limit ?? 10,\n                before: options?.before,\n                metadata: options?.metadata,\n            },\n        });\n    }\n}\nclass RunsClient extends BaseClient {\n    /**\n     * Create a run and stream the results.\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this run.\n     * @param payload Payload for creating a run.\n     */\n    async *stream(threadId, assistantId, payload) {\n        const json = {\n            input: payload?.input,\n            config: payload?.config,\n            metadata: payload?.metadata,\n            stream_mode: payload?.streamMode,\n            feedback_keys: payload?.feedbackKeys,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            checkpoint_id: payload?.checkpointId,\n        };\n        if (payload?.multitaskStrategy != null) {\n            json[\"multitask_strategy\"] = payload?.multitaskStrategy;\n        }\n        const endpoint = threadId == null ? `/runs/stream` : `/threads/${threadId}/runs/stream`;\n        const response = await this.asyncCaller.fetch(...this.prepareFetchOptions(endpoint, {\n            method: \"POST\",\n            json,\n            signal: payload?.signal,\n        }));\n        let parser;\n        let onEndEvent;\n        const textDecoder = new TextDecoder();\n        const stream = (response.body || new ReadableStream({ start: (ctrl) => ctrl.close() })).pipeThrough(new TransformStream({\n            async start(ctrl) {\n                parser = (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_2__.createParser)((event) => {\n                    if ((payload?.signal && payload.signal.aborted) ||\n                        (event.type === \"event\" && event.data === \"[DONE]\")) {\n                        ctrl.terminate();\n                        return;\n                    }\n                    if (\"data\" in event) {\n                        ctrl.enqueue({\n                            event: event.event ?? \"message\",\n                            data: JSON.parse(event.data),\n                        });\n                    }\n                });\n                onEndEvent = () => {\n                    ctrl.enqueue({ event: \"end\", data: undefined });\n                };\n            },\n            async transform(chunk) {\n                const payload = textDecoder.decode(chunk);\n                parser.feed(payload);\n                // eventsource-parser will ignore events\n                // that are not terminated by a newline\n                if (payload.trim() === \"event: end\")\n                    onEndEvent();\n            },\n        }));\n        yield* _utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__.IterableReadableStream.fromReadableStream(stream);\n    }\n    /**\n     * Create a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this run.\n     * @param payload Payload for creating a run.\n     * @returns The created run.\n     */\n    async create(threadId, assistantId, payload) {\n        const json = {\n            input: payload?.input,\n            config: payload?.config,\n            metadata: payload?.metadata,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            webhook: payload?.webhook,\n            checkpoint_id: payload?.checkpointId,\n        };\n        if (payload?.multitaskStrategy != null) {\n            json[\"multitask_strategy\"] = payload?.multitaskStrategy;\n        }\n        return this.fetch(`/threads/${threadId}/runs`, {\n            method: \"POST\",\n            json,\n            signal: payload?.signal,\n        });\n    }\n    /**\n     * Create a run and wait for it to complete.\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this run.\n     * @param payload Payload for creating a run.\n     * @returns The last values chunk of the thread.\n     */\n    async wait(threadId, assistantId, payload) {\n        const json = {\n            input: payload?.input,\n            config: payload?.config,\n            metadata: payload?.metadata,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            checkpoint_id: payload?.checkpointId,\n        };\n        if (payload?.multitaskStrategy != null) {\n            json[\"multitask_strategy\"] = payload?.multitaskStrategy;\n        }\n        const endpoint = threadId == null ? `/runs/wait` : `/threads/${threadId}/runs/wait`;\n        return this.fetch(endpoint, {\n            method: \"POST\",\n            json,\n            signal: payload?.signal,\n        });\n    }\n    /**\n     * List all runs for a thread.\n     *\n     * @param threadId The ID of the thread.\n     * @param options Filtering and pagination options.\n     * @returns List of runs.\n     */\n    async list(threadId, options) {\n        return this.fetch(`/threads/${threadId}/runs`, {\n            params: {\n                limit: options?.limit ?? 10,\n                offset: options?.offset ?? 0,\n            },\n        });\n    }\n    /**\n     * Get a run by ID.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns The run.\n     */\n    async get(threadId, runId) {\n        return this.fetch(`/threads/${threadId}/runs/${runId}`);\n    }\n    /**\n     * Cancel a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @param wait Whether to block when canceling\n     * @returns\n     */\n    async cancel(threadId, runId, wait = false) {\n        return this.fetch(`/threads/${threadId}/runs/${runId}/cancel`, {\n            method: \"POST\",\n            params: {\n                wait: wait ? \"1\" : \"0\",\n            },\n        });\n    }\n    /**\n     * Block until a run is done.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns\n     */\n    async join(threadId, runId) {\n        return this.fetch(`/threads/${threadId}/runs/${runId}/join`);\n    }\n    /**\n     * Delete a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns\n     */\n    async delete(threadId, runId) {\n        return this.fetch(`/threads/${threadId}/runs/${runId}`, {\n            method: \"DELETE\",\n        });\n    }\n}\nclass Client {\n    constructor(config) {\n        /**\n         * The client for interacting with assistants.\n         */\n        Object.defineProperty(this, \"assistants\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with threads.\n         */\n        Object.defineProperty(this, \"threads\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with runs.\n         */\n        Object.defineProperty(this, \"runs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with cron runs.\n         */\n        Object.defineProperty(this, \"crons\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.assistants = new AssistantsClient(config);\n        this.threads = new ThreadsClient(config);\n        this.runs = new RunsClient(config);\n        this.crons = new CronsClient(config);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BsYW5nY2hhaW4rbGFuZ2dyYXBoLXNka0AwLjAuOC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvY2xpZW50Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF1RDtBQUNMO0FBQ1U7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsK0JBQStCLGdFQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2Q0FBNkM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFlBQVksRUFBRSxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBLG9CQUFvQiw2QkFBNkI7QUFDakQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFNBQVMsU0FBUyxhQUFhO0FBQ3pELDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLFNBQVM7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsOERBQThELCtCQUErQjtBQUM3RjtBQUNBLHlCQUF5QixnRUFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxtQ0FBbUMsK0JBQStCO0FBQ2xFO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxlQUFlLHFFQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLFNBQVM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUyxRQUFRLE1BQU07QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUyxRQUFRLE1BQU07QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUyxRQUFRLE1BQU07QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVMsUUFBUSxNQUFNO0FBQzdEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aXRoLWxhbmdncmFwaC8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGgtc2RrQDAuMC44L25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC1zZGsvZGlzdC9jbGllbnQubWpzPzY5MzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXN5bmNDYWxsZXIgfSBmcm9tIFwiLi91dGlscy9hc3luY19jYWxsZXIubWpzXCI7XG5pbXBvcnQgeyBjcmVhdGVQYXJzZXIgfSBmcm9tIFwiZXZlbnRzb3VyY2UtcGFyc2VyXCI7XG5pbXBvcnQgeyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtIH0gZnJvbSBcIi4vdXRpbHMvc3RyZWFtLm1qc1wiO1xuY2xhc3MgQmFzZUNsaWVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFzeW5jQ2FsbGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRpbWVvdXRNc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcGlVcmxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVmYXVsdEhlYWRlcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hc3luY0NhbGxlciA9IG5ldyBBc3luY0NhbGxlcih7XG4gICAgICAgICAgICBtYXhSZXRyaWVzOiA0LFxuICAgICAgICAgICAgbWF4Q29uY3VycmVuY3k6IDQsXG4gICAgICAgICAgICAuLi5jb25maWc/LmNhbGxlck9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRpbWVvdXRNcyA9IGNvbmZpZz8udGltZW91dE1zIHx8IDEyXzAwMDtcbiAgICAgICAgdGhpcy5hcGlVcmwgPSBjb25maWc/LmFwaVVybCB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6ODEyM1wiO1xuICAgICAgICB0aGlzLmRlZmF1bHRIZWFkZXJzID0gY29uZmlnPy5kZWZhdWx0SGVhZGVycyB8fCB7fTtcbiAgICAgICAgaWYgKGNvbmZpZz8uYXBpS2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdEhlYWRlcnNbXCJYLUFwaS1LZXlcIl0gPSBjb25maWcuYXBpS2V5O1xuICAgICAgICB9XG4gICAgfVxuICAgIHByZXBhcmVGZXRjaE9wdGlvbnMocGF0aCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBtdXRhdGVkT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuZGVmYXVsdEhlYWRlcnMsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG11dGF0ZWRPcHRpb25zLmpzb24pIHtcbiAgICAgICAgICAgIG11dGF0ZWRPcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShtdXRhdGVkT3B0aW9ucy5qc29uKTtcbiAgICAgICAgICAgIG11dGF0ZWRPcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgLi4ubXV0YXRlZE9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWxldGUgbXV0YXRlZE9wdGlvbnMuanNvbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRVcmwgPSBuZXcgVVJMKGAke3RoaXMuYXBpVXJsfSR7cGF0aH1gKTtcbiAgICAgICAgaWYgKG11dGF0ZWRPcHRpb25zLnBhcmFtcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobXV0YXRlZE9wdGlvbnMucGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBsZXQgc3RyVmFsdWUgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICAgICAgICAgID8gdmFsdWUudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHN0clZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBtdXRhdGVkT3B0aW9ucy5wYXJhbXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0YXJnZXRVcmwsIG11dGF0ZWRPcHRpb25zXTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2gocGF0aCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXN5bmNDYWxsZXIuZmV0Y2goLi4udGhpcy5wcmVwYXJlRmV0Y2hPcHRpb25zKHBhdGgsIG9wdGlvbnMpKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAyIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA0KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENyb25zQ2xpZW50IGV4dGVuZHMgQmFzZUNsaWVudCB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGhyZWFkSWQgVGhlIElEIG9mIHRoZSB0aHJlYWQuXG4gICAgICogQHBhcmFtIGFzc2lzdGFudElkIEFzc2lzdGFudCBJRCB0byB1c2UgZm9yIHRoaXMgY3JvbiBqb2IuXG4gICAgICogQHBhcmFtIHBheWxvYWQgUGF5bG9hZCBmb3IgY3JlYXRpbmcgYSBjcm9uIGpvYi5cbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBiYWNrZ3JvdW5kIHJ1bi5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVGb3JUaHJlYWQodGhyZWFkSWQsIGFzc2lzdGFudElkLCBwYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IGpzb24gPSB7XG4gICAgICAgICAgICBzY2hlZHVsZTogcGF5bG9hZD8uc2NoZWR1bGUsXG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZD8uaW5wdXQsXG4gICAgICAgICAgICBjb25maWc6IHBheWxvYWQ/LmNvbmZpZyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBwYXlsb2FkPy5tZXRhZGF0YSxcbiAgICAgICAgICAgIGFzc2lzdGFudF9pZDogYXNzaXN0YW50SWQsXG4gICAgICAgICAgICBpbnRlcnJ1cHRfYmVmb3JlOiBwYXlsb2FkPy5pbnRlcnJ1cHRCZWZvcmUsXG4gICAgICAgICAgICBpbnRlcnJ1cHRfYWZ0ZXI6IHBheWxvYWQ/LmludGVycnVwdEFmdGVyLFxuICAgICAgICAgICAgd2ViaG9vazogcGF5bG9hZD8ud2ViaG9vayxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC90aHJlYWRzLyR7dGhyZWFkSWR9L3J1bnMvY3JvbnNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAganNvbixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzc2lzdGFudElkIEFzc2lzdGFudCBJRCB0byB1c2UgZm9yIHRoaXMgY3JvbiBqb2IuXG4gICAgICogQHBhcmFtIHBheWxvYWQgUGF5bG9hZCBmb3IgY3JlYXRpbmcgYSBjcm9uIGpvYi5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZShhc3Npc3RhbnRJZCwgcGF5bG9hZCkge1xuICAgICAgICBjb25zdCBqc29uID0ge1xuICAgICAgICAgICAgc2NoZWR1bGU6IHBheWxvYWQ/LnNjaGVkdWxlLFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQ/LmlucHV0LFxuICAgICAgICAgICAgY29uZmlnOiBwYXlsb2FkPy5jb25maWcsXG4gICAgICAgICAgICBtZXRhZGF0YTogcGF5bG9hZD8ubWV0YWRhdGEsXG4gICAgICAgICAgICBhc3Npc3RhbnRfaWQ6IGFzc2lzdGFudElkLFxuICAgICAgICAgICAgaW50ZXJydXB0X2JlZm9yZTogcGF5bG9hZD8uaW50ZXJydXB0QmVmb3JlLFxuICAgICAgICAgICAgaW50ZXJydXB0X2FmdGVyOiBwYXlsb2FkPy5pbnRlcnJ1cHRBZnRlcixcbiAgICAgICAgICAgIHdlYmhvb2s6IHBheWxvYWQ/LndlYmhvb2ssXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvcnVucy9jcm9uc2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBqc29uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY3JvbklkIENyb24gSUQgb2YgQ3JvbiBqb2IgdG8gZGVsZXRlLlxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShjcm9uSWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5mZXRjaChgL3J1bnMvY3JvbnMvJHtjcm9uSWR9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcXVlcnkgUXVlcnkgb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJucyBMaXN0IG9mIGNyb25zLlxuICAgICAqL1xuICAgIGFzeW5jIHNlYXJjaChxdWVyeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcIi9ydW5zL2Nyb25zL3NlYXJjaFwiLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAganNvbjoge1xuICAgICAgICAgICAgICAgIGFzc2lzdGFudF9pZDogcXVlcnk/LmFzc2lzdGFudElkID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB0aHJlYWRfaWQ6IHF1ZXJ5Py50aHJlYWRJZCA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbGltaXQ6IHF1ZXJ5Py5saW1pdCA/PyAxMCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHF1ZXJ5Py5vZmZzZXQgPz8gMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBc3Npc3RhbnRzQ2xpZW50IGV4dGVuZHMgQmFzZUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogR2V0IGFuIGFzc2lzdGFudCBieSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3Npc3RhbnRJZCBUaGUgSUQgb2YgdGhlIGFzc2lzdGFudC5cbiAgICAgKiBAcmV0dXJucyBBc3Npc3RhbnRcbiAgICAgKi9cbiAgICBhc3luYyBnZXQoYXNzaXN0YW50SWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC9hc3Npc3RhbnRzLyR7YXNzaXN0YW50SWR9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ3JhcGggYXNzaWduZWQgdG8gYSBydW5uYWJsZVxuICAgICAqIEBwYXJhbSBhc3Npc3RhbnRJZCBUaGUgSUQgb2YgdGhlIGFzc2lzdGFudC5cbiAgICAgKiBAcmV0dXJucyBTZXJpYWxpemVkIGdyYXBoXG4gICAgICovXG4gICAgYXN5bmMgZ2V0R3JhcGgoYXNzaXN0YW50SWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC9hc3Npc3RhbnRzLyR7YXNzaXN0YW50SWR9L2dyYXBoYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3RhdGUgYW5kIGNvbmZpZyBzY2hlbWEgb2YgdGhlIGdyYXBoIGFzc2lnbmVkIHRvIGEgcnVubmFibGVcbiAgICAgKiBAcGFyYW0gYXNzaXN0YW50SWQgVGhlIElEIG9mIHRoZSBhc3Npc3RhbnQuXG4gICAgICogQHJldHVybnMgR3JhcGggc2NoZW1hXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U2NoZW1hcyhhc3Npc3RhbnRJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL2Fzc2lzdGFudHMvJHthc3Npc3RhbnRJZH0vc2NoZW1hc2ApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgYXNzaXN0YW50LlxuICAgICAqIEBwYXJhbSBwYXlsb2FkIFBheWxvYWQgZm9yIGNyZWF0aW5nIGFuIGFzc2lzdGFudC5cbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBhc3Npc3RhbnQuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCIvYXNzaXN0YW50c1wiLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAganNvbjoge1xuICAgICAgICAgICAgICAgIGdyYXBoX2lkOiBwYXlsb2FkLmdyYXBoSWQsXG4gICAgICAgICAgICAgICAgY29uZmlnOiBwYXlsb2FkLmNvbmZpZyxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogcGF5bG9hZC5tZXRhZGF0YSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYW4gYXNzaXN0YW50LlxuICAgICAqIEBwYXJhbSBhc3Npc3RhbnRJZCBJRCBvZiB0aGUgYXNzaXN0YW50LlxuICAgICAqIEBwYXJhbSBwYXlsb2FkIFBheWxvYWQgZm9yIHVwZGF0aW5nIHRoZSBhc3Npc3RhbnQuXG4gICAgICogQHJldHVybnMgVGhlIHVwZGF0ZWQgYXNzaXN0YW50LlxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZShhc3Npc3RhbnRJZCwgcGF5bG9hZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL2Fzc2lzdGFudHMvJHthc3Npc3RhbnRJZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgIGpzb246IHtcbiAgICAgICAgICAgICAgICBncmFwaF9pZDogcGF5bG9hZC5ncmFwaElkLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogcGF5bG9hZC5jb25maWcsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHBheWxvYWQubWV0YWRhdGEsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGFuIGFzc2lzdGFudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3Npc3RhbnRJZCBJRCBvZiB0aGUgYXNzaXN0YW50LlxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShhc3Npc3RhbnRJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL2Fzc2lzdGFudHMvJHthc3Npc3RhbnRJZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGFzc2lzdGFudHMuXG4gICAgICogQHBhcmFtIHF1ZXJ5IFF1ZXJ5IG9wdGlvbnMuXG4gICAgICogQHJldHVybnMgTGlzdCBvZiBhc3Npc3RhbnRzLlxuICAgICAqL1xuICAgIGFzeW5jIHNlYXJjaChxdWVyeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcIi9hc3Npc3RhbnRzL3NlYXJjaFwiLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAganNvbjoge1xuICAgICAgICAgICAgICAgIGdyYXBoX2lkOiBxdWVyeT8uZ3JhcGhJZCA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHF1ZXJ5Py5tZXRhZGF0YSA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbGltaXQ6IHF1ZXJ5Py5saW1pdCA/PyAxMCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHF1ZXJ5Py5vZmZzZXQgPz8gMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBUaHJlYWRzQ2xpZW50IGV4dGVuZHMgQmFzZUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogR2V0IGEgdGhyZWFkIGJ5IElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHRocmVhZElkIElEIG9mIHRoZSB0aHJlYWQuXG4gICAgICogQHJldHVybnMgVGhlIHRocmVhZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXQodGhyZWFkSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC90aHJlYWRzLyR7dGhyZWFkSWR9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyB0aHJlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF5bG9hZCBQYXlsb2FkIGZvciBjcmVhdGluZyBhIHRocmVhZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCB0aHJlYWQuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC90aHJlYWRzYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGpzb246IHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogcGF5bG9hZD8ubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgdGhyZWFkX2lkOiBwYXlsb2FkPy50aHJlYWRJZCxcbiAgICAgICAgICAgICAgICBpZl9leGlzdHM6IHBheWxvYWQ/LmlmRXhpc3RzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcHkgYW4gZXhpc3RpbmcgdGhyZWFkXG4gICAgICogQHBhcmFtIHRocmVhZElkIElEIG9mIHRoZSB0aHJlYWQgdG8gYmUgY29waWVkXG4gICAgICogQHJldHVybnMgTmV3bHkgY29waWVkIHRocmVhZFxuICAgICAqL1xuICAgIGFzeW5jIGNvcHkodGhyZWFkSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC90aHJlYWRzLyR7dGhyZWFkSWR9L2NvcHlgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGEgdGhyZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRocmVhZElkIElEIG9mIHRoZSB0aHJlYWQuXG4gICAgICogQHBhcmFtIHBheWxvYWQgUGF5bG9hZCBmb3IgdXBkYXRpbmcgdGhlIHRocmVhZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdXBkYXRlZCB0aHJlYWQuXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlKHRocmVhZElkLCBwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvdGhyZWFkcy8ke3RocmVhZElkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAganNvbjogeyBtZXRhZGF0YTogcGF5bG9hZD8ubWV0YWRhdGEgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHRocmVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aHJlYWRJZCBJRCBvZiB0aGUgdGhyZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZSh0aHJlYWRJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHMvJHt0aHJlYWRJZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IHRocmVhZHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBxdWVyeSBRdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybnMgTGlzdCBvZiB0aHJlYWRzXG4gICAgICovXG4gICAgYXN5bmMgc2VhcmNoKHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwiL3RocmVhZHMvc2VhcmNoXCIsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBqc29uOiB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHF1ZXJ5Py5tZXRhZGF0YSA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbGltaXQ6IHF1ZXJ5Py5saW1pdCA/PyAxMCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHF1ZXJ5Py5vZmZzZXQgPz8gMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgc3RhdGUgZm9yIGEgdGhyZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRocmVhZElkIElEIG9mIHRoZSB0aHJlYWQuXG4gICAgICogQHJldHVybnMgVGhyZWFkIHN0YXRlLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFN0YXRlKHRocmVhZElkLCBjaGVja3BvaW50SWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goY2hlY2twb2ludElkICE9IG51bGxcbiAgICAgICAgICAgID8gYC90aHJlYWRzLyR7dGhyZWFkSWR9L3N0YXRlLyR7Y2hlY2twb2ludElkfWBcbiAgICAgICAgICAgIDogYC90aHJlYWRzLyR7dGhyZWFkSWR9L3N0YXRlYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBzdGF0ZSB0byBhIHRocmVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aHJlYWRJZCBUaGUgSUQgb2YgdGhlIHRocmVhZC5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVN0YXRlKHRocmVhZElkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvdGhyZWFkcy8ke3RocmVhZElkfS9zdGF0ZWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBqc29uOiB7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiBvcHRpb25zLnZhbHVlcyxcbiAgICAgICAgICAgICAgICBjaGVja3BvaW50X2lkOiBvcHRpb25zLmNoZWNrcG9pbnRJZCxcbiAgICAgICAgICAgICAgICBhc19ub2RlOiBvcHRpb25zPy5hc05vZGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGF0Y2ggdGhlIG1ldGFkYXRhIG9mIGEgdGhyZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRocmVhZElkT3JDb25maWcgVGhyZWFkIElEIG9yIGNvbmZpZyB0byBwYXRjaCB0aGUgc3RhdGUgb2YuXG4gICAgICogQHBhcmFtIG1ldGFkYXRhIE1ldGFkYXRhIHRvIHBhdGNoIHRoZSBzdGF0ZSB3aXRoLlxuICAgICAqL1xuICAgIGFzeW5jIHBhdGNoU3RhdGUodGhyZWFkSWRPckNvbmZpZywgbWV0YWRhdGEpIHtcbiAgICAgICAgbGV0IHRocmVhZElkO1xuICAgICAgICBpZiAodHlwZW9mIHRocmVhZElkT3JDb25maWcgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhyZWFkSWRPckNvbmZpZy5jb25maWd1cmFibGUudGhyZWFkX2lkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhyZWFkIElEIGlzIHJlcXVpcmVkIHdoZW4gdXBkYXRpbmcgc3RhdGUgd2l0aCBhIGNvbmZpZy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJlYWRJZCA9IHRocmVhZElkT3JDb25maWcuY29uZmlndXJhYmxlLnRocmVhZF9pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocmVhZElkID0gdGhyZWFkSWRPckNvbmZpZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHMvJHt0aHJlYWRJZH0vc3RhdGVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgIGpzb246IHsgbWV0YWRhdGE6IG1ldGFkYXRhIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHBhc3Qgc3RhdGVzIGZvciBhIHRocmVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aHJlYWRJZCBJRCBvZiB0aGUgdGhyZWFkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJucyBMaXN0IG9mIHRocmVhZCBzdGF0ZXMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0SGlzdG9yeSh0aHJlYWRJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHMvJHt0aHJlYWRJZH0vaGlzdG9yeWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBqc29uOiB7XG4gICAgICAgICAgICAgICAgbGltaXQ6IG9wdGlvbnM/LmxpbWl0ID8/IDEwLFxuICAgICAgICAgICAgICAgIGJlZm9yZTogb3B0aW9ucz8uYmVmb3JlLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBvcHRpb25zPy5tZXRhZGF0YSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSdW5zQ2xpZW50IGV4dGVuZHMgQmFzZUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgcnVuIGFuZCBzdHJlYW0gdGhlIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGhyZWFkSWQgVGhlIElEIG9mIHRoZSB0aHJlYWQuXG4gICAgICogQHBhcmFtIGFzc2lzdGFudElkIEFzc2lzdGFudCBJRCB0byB1c2UgZm9yIHRoaXMgcnVuLlxuICAgICAqIEBwYXJhbSBwYXlsb2FkIFBheWxvYWQgZm9yIGNyZWF0aW5nIGEgcnVuLlxuICAgICAqL1xuICAgIGFzeW5jICpzdHJlYW0odGhyZWFkSWQsIGFzc2lzdGFudElkLCBwYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IGpzb24gPSB7XG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZD8uaW5wdXQsXG4gICAgICAgICAgICBjb25maWc6IHBheWxvYWQ/LmNvbmZpZyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBwYXlsb2FkPy5tZXRhZGF0YSxcbiAgICAgICAgICAgIHN0cmVhbV9tb2RlOiBwYXlsb2FkPy5zdHJlYW1Nb2RlLFxuICAgICAgICAgICAgZmVlZGJhY2tfa2V5czogcGF5bG9hZD8uZmVlZGJhY2tLZXlzLFxuICAgICAgICAgICAgYXNzaXN0YW50X2lkOiBhc3Npc3RhbnRJZCxcbiAgICAgICAgICAgIGludGVycnVwdF9iZWZvcmU6IHBheWxvYWQ/LmludGVycnVwdEJlZm9yZSxcbiAgICAgICAgICAgIGludGVycnVwdF9hZnRlcjogcGF5bG9hZD8uaW50ZXJydXB0QWZ0ZXIsXG4gICAgICAgICAgICBjaGVja3BvaW50X2lkOiBwYXlsb2FkPy5jaGVja3BvaW50SWQsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwYXlsb2FkPy5tdWx0aXRhc2tTdHJhdGVneSAhPSBudWxsKSB7XG4gICAgICAgICAgICBqc29uW1wibXVsdGl0YXNrX3N0cmF0ZWd5XCJdID0gcGF5bG9hZD8ubXVsdGl0YXNrU3RyYXRlZ3k7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5kcG9pbnQgPSB0aHJlYWRJZCA9PSBudWxsID8gYC9ydW5zL3N0cmVhbWAgOiBgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVucy9zdHJlYW1gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXN5bmNDYWxsZXIuZmV0Y2goLi4udGhpcy5wcmVwYXJlRmV0Y2hPcHRpb25zKGVuZHBvaW50LCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAganNvbixcbiAgICAgICAgICAgIHNpZ25hbDogcGF5bG9hZD8uc2lnbmFsLFxuICAgICAgICB9KSk7XG4gICAgICAgIGxldCBwYXJzZXI7XG4gICAgICAgIGxldCBvbkVuZEV2ZW50O1xuICAgICAgICBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgICAgICBjb25zdCBzdHJlYW0gPSAocmVzcG9uc2UuYm9keSB8fCBuZXcgUmVhZGFibGVTdHJlYW0oeyBzdGFydDogKGN0cmwpID0+IGN0cmwuY2xvc2UoKSB9KSkucGlwZVRocm91Z2gobmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgICBhc3luYyBzdGFydChjdHJsKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyID0gY3JlYXRlUGFyc2VyKChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHBheWxvYWQ/LnNpZ25hbCAmJiBwYXlsb2FkLnNpZ25hbC5hYm9ydGVkKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGV2ZW50LnR5cGUgPT09IFwiZXZlbnRcIiAmJiBldmVudC5kYXRhID09PSBcIltET05FXVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoXCJkYXRhXCIgaW4gZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LmV2ZW50ID8/IFwibWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IEpTT04ucGFyc2UoZXZlbnQuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9uRW5kRXZlbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZW5xdWV1ZSh7IGV2ZW50OiBcImVuZFwiLCBkYXRhOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gdGV4dERlY29kZXIuZGVjb2RlKGNodW5rKTtcbiAgICAgICAgICAgICAgICBwYXJzZXIuZmVlZChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAvLyBldmVudHNvdXJjZS1wYXJzZXIgd2lsbCBpZ25vcmUgZXZlbnRzXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBhcmUgbm90IHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lXG4gICAgICAgICAgICAgICAgaWYgKHBheWxvYWQudHJpbSgpID09PSBcImV2ZW50OiBlbmRcIilcbiAgICAgICAgICAgICAgICAgICAgb25FbmRFdmVudCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkpO1xuICAgICAgICB5aWVsZCogSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tUmVhZGFibGVTdHJlYW0oc3RyZWFtKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgcnVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRocmVhZElkIFRoZSBJRCBvZiB0aGUgdGhyZWFkLlxuICAgICAqIEBwYXJhbSBhc3Npc3RhbnRJZCBBc3Npc3RhbnQgSUQgdG8gdXNlIGZvciB0aGlzIHJ1bi5cbiAgICAgKiBAcGFyYW0gcGF5bG9hZCBQYXlsb2FkIGZvciBjcmVhdGluZyBhIHJ1bi5cbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBydW4uXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKHRocmVhZElkLCBhc3Npc3RhbnRJZCwgcGF5bG9hZCkge1xuICAgICAgICBjb25zdCBqc29uID0ge1xuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQ/LmlucHV0LFxuICAgICAgICAgICAgY29uZmlnOiBwYXlsb2FkPy5jb25maWcsXG4gICAgICAgICAgICBtZXRhZGF0YTogcGF5bG9hZD8ubWV0YWRhdGEsXG4gICAgICAgICAgICBhc3Npc3RhbnRfaWQ6IGFzc2lzdGFudElkLFxuICAgICAgICAgICAgaW50ZXJydXB0X2JlZm9yZTogcGF5bG9hZD8uaW50ZXJydXB0QmVmb3JlLFxuICAgICAgICAgICAgaW50ZXJydXB0X2FmdGVyOiBwYXlsb2FkPy5pbnRlcnJ1cHRBZnRlcixcbiAgICAgICAgICAgIHdlYmhvb2s6IHBheWxvYWQ/LndlYmhvb2ssXG4gICAgICAgICAgICBjaGVja3BvaW50X2lkOiBwYXlsb2FkPy5jaGVja3BvaW50SWQsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwYXlsb2FkPy5tdWx0aXRhc2tTdHJhdGVneSAhPSBudWxsKSB7XG4gICAgICAgICAgICBqc29uW1wibXVsdGl0YXNrX3N0cmF0ZWd5XCJdID0gcGF5bG9hZD8ubXVsdGl0YXNrU3RyYXRlZ3k7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC90aHJlYWRzLyR7dGhyZWFkSWR9L3J1bnNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAganNvbixcbiAgICAgICAgICAgIHNpZ25hbDogcGF5bG9hZD8uc2lnbmFsLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgcnVuIGFuZCB3YWl0IGZvciBpdCB0byBjb21wbGV0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aHJlYWRJZCBUaGUgSUQgb2YgdGhlIHRocmVhZC5cbiAgICAgKiBAcGFyYW0gYXNzaXN0YW50SWQgQXNzaXN0YW50IElEIHRvIHVzZSBmb3IgdGhpcyBydW4uXG4gICAgICogQHBhcmFtIHBheWxvYWQgUGF5bG9hZCBmb3IgY3JlYXRpbmcgYSBydW4uXG4gICAgICogQHJldHVybnMgVGhlIGxhc3QgdmFsdWVzIGNodW5rIG9mIHRoZSB0aHJlYWQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdCh0aHJlYWRJZCwgYXNzaXN0YW50SWQsIHBheWxvYWQpIHtcbiAgICAgICAgY29uc3QganNvbiA9IHtcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkPy5pbnB1dCxcbiAgICAgICAgICAgIGNvbmZpZzogcGF5bG9hZD8uY29uZmlnLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHBheWxvYWQ/Lm1ldGFkYXRhLFxuICAgICAgICAgICAgYXNzaXN0YW50X2lkOiBhc3Npc3RhbnRJZCxcbiAgICAgICAgICAgIGludGVycnVwdF9iZWZvcmU6IHBheWxvYWQ/LmludGVycnVwdEJlZm9yZSxcbiAgICAgICAgICAgIGludGVycnVwdF9hZnRlcjogcGF5bG9hZD8uaW50ZXJydXB0QWZ0ZXIsXG4gICAgICAgICAgICBjaGVja3BvaW50X2lkOiBwYXlsb2FkPy5jaGVja3BvaW50SWQsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwYXlsb2FkPy5tdWx0aXRhc2tTdHJhdGVneSAhPSBudWxsKSB7XG4gICAgICAgICAgICBqc29uW1wibXVsdGl0YXNrX3N0cmF0ZWd5XCJdID0gcGF5bG9hZD8ubXVsdGl0YXNrU3RyYXRlZ3k7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5kcG9pbnQgPSB0aHJlYWRJZCA9PSBudWxsID8gYC9ydW5zL3dhaXRgIDogYC90aHJlYWRzLyR7dGhyZWFkSWR9L3J1bnMvd2FpdGA7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGVuZHBvaW50LCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAganNvbixcbiAgICAgICAgICAgIHNpZ25hbDogcGF5bG9hZD8uc2lnbmFsLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBhbGwgcnVucyBmb3IgYSB0aHJlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGhyZWFkSWQgVGhlIElEIG9mIHRoZSB0aHJlYWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgRmlsdGVyaW5nIGFuZCBwYWdpbmF0aW9uIG9wdGlvbnMuXG4gICAgICogQHJldHVybnMgTGlzdCBvZiBydW5zLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3QodGhyZWFkSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC90aHJlYWRzLyR7dGhyZWFkSWR9L3J1bnNgLCB7XG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBsaW1pdDogb3B0aW9ucz8ubGltaXQgPz8gMTAsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBvcHRpb25zPy5vZmZzZXQgPz8gMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBydW4gYnkgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGhyZWFkSWQgVGhlIElEIG9mIHRoZSB0aHJlYWQuXG4gICAgICogQHBhcmFtIHJ1bklkIFRoZSBJRCBvZiB0aGUgcnVuLlxuICAgICAqIEByZXR1cm5zIFRoZSBydW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHRocmVhZElkLCBydW5JZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVucy8ke3J1bklkfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgYSBydW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGhyZWFkSWQgVGhlIElEIG9mIHRoZSB0aHJlYWQuXG4gICAgICogQHBhcmFtIHJ1bklkIFRoZSBJRCBvZiB0aGUgcnVuLlxuICAgICAqIEBwYXJhbSB3YWl0IFdoZXRoZXIgdG8gYmxvY2sgd2hlbiBjYW5jZWxpbmdcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGFzeW5jIGNhbmNlbCh0aHJlYWRJZCwgcnVuSWQsIHdhaXQgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVucy8ke3J1bklkfS9jYW5jZWxgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgd2FpdDogd2FpdCA/IFwiMVwiIDogXCIwXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmxvY2sgdW50aWwgYSBydW4gaXMgZG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aHJlYWRJZCBUaGUgSUQgb2YgdGhlIHRocmVhZC5cbiAgICAgKiBAcGFyYW0gcnVuSWQgVGhlIElEIG9mIHRoZSBydW4uXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBhc3luYyBqb2luKHRocmVhZElkLCBydW5JZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVucy8ke3J1bklkfS9qb2luYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHJ1bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aHJlYWRJZCBUaGUgSUQgb2YgdGhlIHRocmVhZC5cbiAgICAgKiBAcGFyYW0gcnVuSWQgVGhlIElEIG9mIHRoZSBydW4uXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUodGhyZWFkSWQsIHJ1bklkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zLyR7cnVuSWR9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbGllbnQgZm9yIGludGVyYWN0aW5nIHdpdGggYXNzaXN0YW50cy5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFzc2lzdGFudHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbGllbnQgZm9yIGludGVyYWN0aW5nIHdpdGggdGhyZWFkcy5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRocmVhZHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbGllbnQgZm9yIGludGVyYWN0aW5nIHdpdGggcnVucy5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJ1bnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbGllbnQgZm9yIGludGVyYWN0aW5nIHdpdGggY3JvbiBydW5zLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY3JvbnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hc3Npc3RhbnRzID0gbmV3IEFzc2lzdGFudHNDbGllbnQoY29uZmlnKTtcbiAgICAgICAgdGhpcy50aHJlYWRzID0gbmV3IFRocmVhZHNDbGllbnQoY29uZmlnKTtcbiAgICAgICAgdGhpcy5ydW5zID0gbmV3IFJ1bnNDbGllbnQoY29uZmlnKTtcbiAgICAgICAgdGhpcy5jcm9ucyA9IG5ldyBDcm9uc0NsaWVudChjb25maWcpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/@langchain+langgraph-sdk@0.0.8/node_modules/@langchain/langgraph-sdk/dist/client.mjs\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/@langchain+langgraph-sdk@0.0.8/node_modules/@langchain/langgraph-sdk/dist/index.mjs":
/*!*****************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@langchain+langgraph-sdk@0.0.8/node_modules/@langchain/langgraph-sdk/dist/index.mjs ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* reexport safe */ _client_mjs__WEBPACK_IMPORTED_MODULE_0__.Client)\n/* harmony export */ });\n/* harmony import */ var _client_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client.mjs */ \"(ssr)/../node_modules/.pnpm/@langchain+langgraph-sdk@0.0.8/node_modules/@langchain/langgraph-sdk/dist/client.mjs\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BsYW5nY2hhaW4rbGFuZ2dyYXBoLXNka0AwLjAuOC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2l0aC1sYW5nZ3JhcGgvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BsYW5nY2hhaW4rbGFuZ2dyYXBoLXNka0AwLjAuOC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvaW5kZXgubWpzPzE0YjEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgQ2xpZW50IH0gZnJvbSBcIi4vY2xpZW50Lm1qc1wiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/@langchain+langgraph-sdk@0.0.8/node_modules/@langchain/langgraph-sdk/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/@langchain+langgraph-sdk@0.0.8/node_modules/@langchain/langgraph-sdk/dist/utils/async_caller.mjs":
/*!******************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@langchain+langgraph-sdk@0.0.8/node_modules/@langchain/langgraph-sdk/dist/utils/async_caller.mjs ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncCaller: () => (/* binding */ AsyncCaller)\n/* harmony export */ });\n/* harmony import */ var p_retry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-retry */ \"(ssr)/../node_modules/.pnpm/p-retry@4.6.2/node_modules/p-retry/index.js\");\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-queue */ \"(ssr)/../node_modules/.pnpm/p-queue@6.6.2/node_modules/p-queue/dist/index.js\");\n\n\nconst STATUS_NO_RETRY = [\n    400, // Bad Request\n    401, // Unauthorized\n    403, // Forbidden\n    404, // Not Found\n    405, // Method Not Allowed\n    406, // Not Acceptable\n    407, // Proxy Authentication Required\n    408, // Request Timeout\n    422, // Unprocessable Entity\n];\nconst STATUS_IGNORE = [\n    409, // Conflict\n];\n/**\n * Do not rely on globalThis.Response, rather just\n * do duck typing\n */\nfunction isResponse(x) {\n    if (x == null || typeof x !== \"object\")\n        return false;\n    return \"status\" in x && \"statusText\" in x && \"text\" in x;\n}\n/**\n * Utility error to properly handle failed requests\n */\nclass HTTPError extends Error {\n    constructor(status, message, response) {\n        super(`HTTP ${status}: ${message}`);\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"text\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"response\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.status = status;\n        this.text = message;\n        this.response = response;\n    }\n    static async fromResponse(response, options) {\n        try {\n            return new HTTPError(response.status, await response.text(), options?.includeResponse ? response : undefined);\n        }\n        catch {\n            return new HTTPError(response.status, response.statusText, options?.includeResponse ? response : undefined);\n        }\n    }\n}\n/**\n * A class that can be used to make async calls with concurrency and retry logic.\n *\n * This is useful for making calls to any kind of \"expensive\" external resource,\n * be it because it's rate-limited, subject to network issues, etc.\n *\n * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults\n * to `Infinity`. This means that by default, all calls will be made in parallel.\n *\n * Retries are limited by the `maxRetries` parameter, which defaults to 5. This\n * means that by default, each call will be retried up to 5 times, with an\n * exponential backoff between each attempt.\n */\nclass AsyncCaller {\n    constructor(params) {\n        Object.defineProperty(this, \"maxConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxRetries\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"onFailedResponseHook\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"customFetch\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxConcurrency = params.maxConcurrency ?? Infinity;\n        this.maxRetries = params.maxRetries ?? 4;\n        if ( true) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new p_queue__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n                concurrency: this.maxConcurrency,\n            });\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new p_queue__WEBPACK_IMPORTED_MODULE_1__({ concurrency: this.maxConcurrency });\n        }\n        this.onFailedResponseHook = params?.onFailedResponseHook;\n        this.customFetch = params.fetch;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    call(callable, ...args) {\n        const onFailedResponseHook = this.onFailedResponseHook;\n        return this.queue.add(() => p_retry__WEBPACK_IMPORTED_MODULE_0__(() => callable(...args).catch(async (error) => {\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (error instanceof Error) {\n                throw error;\n            }\n            else if (isResponse(error)) {\n                throw await HTTPError.fromResponse(error, {\n                    includeResponse: !!onFailedResponseHook,\n                });\n            }\n            else {\n                throw new Error(error);\n            }\n        }), {\n            async onFailedAttempt(error) {\n                if (error.message.startsWith(\"Cancel\") ||\n                    error.message.startsWith(\"TimeoutError\") ||\n                    error.message.startsWith(\"AbortError\")) {\n                    throw error;\n                }\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                if (error?.code === \"ECONNABORTED\") {\n                    throw error;\n                }\n                if (error instanceof HTTPError) {\n                    if (STATUS_NO_RETRY.includes(error.status)) {\n                        throw error;\n                    }\n                    else if (STATUS_IGNORE.includes(error.status)) {\n                        return;\n                    }\n                    if (onFailedResponseHook && error.response) {\n                        await onFailedResponseHook(error.response);\n                    }\n                }\n            },\n            // If needed we can change some of the defaults here,\n            // but they're quite sensible.\n            retries: this.maxRetries,\n            randomize: true,\n        }), { throwOnTimeout: true });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callWithOptions(options, callable, ...args) {\n        // Note this doesn't cancel the underlying request,\n        // when available prefer to use the signal option of the underlying call\n        if (options.signal) {\n            return Promise.race([\n                this.call(callable, ...args),\n                new Promise((_, reject) => {\n                    options.signal?.addEventListener(\"abort\", () => {\n                        reject(new Error(\"AbortError\"));\n                    });\n                }),\n            ]);\n        }\n        return this.call(callable, ...args);\n    }\n    fetch(...args) {\n        const fetchFn = this.customFetch ?? fetch;\n        return this.call(() => fetchFn(...args).then((res) => (res.ok ? res : Promise.reject(res))));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BsYW5nY2hhaW4rbGFuZ2dyYXBoLXNka0AwLjAuOC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNkI7QUFDRztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPLElBQUksUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsWUFBWSxLQUFzQjtBQUNsQztBQUNBLDZCQUE2QiwrQ0FBaUI7QUFDOUM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG9DQUFTLEdBQUcsa0NBQWtDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9DQUFNO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsS0FBSyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2l0aC1sYW5nZ3JhcGgvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BsYW5nY2hhaW4rbGFuZ2dyYXBoLXNka0AwLjAuOC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLm1qcz9lYzQ3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwUmV0cnkgZnJvbSBcInAtcmV0cnlcIjtcbmltcG9ydCBQUXVldWVNb2QgZnJvbSBcInAtcXVldWVcIjtcbmNvbnN0IFNUQVRVU19OT19SRVRSWSA9IFtcbiAgICA0MDAsIC8vIEJhZCBSZXF1ZXN0XG4gICAgNDAxLCAvLyBVbmF1dGhvcml6ZWRcbiAgICA0MDMsIC8vIEZvcmJpZGRlblxuICAgIDQwNCwgLy8gTm90IEZvdW5kXG4gICAgNDA1LCAvLyBNZXRob2QgTm90IEFsbG93ZWRcbiAgICA0MDYsIC8vIE5vdCBBY2NlcHRhYmxlXG4gICAgNDA3LCAvLyBQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFxuICAgIDQwOCwgLy8gUmVxdWVzdCBUaW1lb3V0XG4gICAgNDIyLCAvLyBVbnByb2Nlc3NhYmxlIEVudGl0eVxuXTtcbmNvbnN0IFNUQVRVU19JR05PUkUgPSBbXG4gICAgNDA5LCAvLyBDb25mbGljdFxuXTtcbi8qKlxuICogRG8gbm90IHJlbHkgb24gZ2xvYmFsVGhpcy5SZXNwb25zZSwgcmF0aGVyIGp1c3RcbiAqIGRvIGR1Y2sgdHlwaW5nXG4gKi9cbmZ1bmN0aW9uIGlzUmVzcG9uc2UoeCkge1xuICAgIGlmICh4ID09IG51bGwgfHwgdHlwZW9mIHggIT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gXCJzdGF0dXNcIiBpbiB4ICYmIFwic3RhdHVzVGV4dFwiIGluIHggJiYgXCJ0ZXh0XCIgaW4geDtcbn1cbi8qKlxuICogVXRpbGl0eSBlcnJvciB0byBwcm9wZXJseSBoYW5kbGUgZmFpbGVkIHJlcXVlc3RzXG4gKi9cbmNsYXNzIEhUVFBFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzdGF0dXMsIG1lc3NhZ2UsIHJlc3BvbnNlKSB7XG4gICAgICAgIHN1cGVyKGBIVFRQICR7c3RhdHVzfTogJHttZXNzYWdlfWApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0dXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGV4dFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXNwb25zZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdGhpcy50ZXh0ID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgZnJvbVJlc3BvbnNlKHJlc3BvbnNlLCBvcHRpb25zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhUVFBFcnJvcihyZXNwb25zZS5zdGF0dXMsIGF3YWl0IHJlc3BvbnNlLnRleHQoKSwgb3B0aW9ucz8uaW5jbHVkZVJlc3BvbnNlID8gcmVzcG9uc2UgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSFRUUEVycm9yKHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2Uuc3RhdHVzVGV4dCwgb3B0aW9ucz8uaW5jbHVkZVJlc3BvbnNlID8gcmVzcG9uc2UgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBIGNsYXNzIHRoYXQgY2FuIGJlIHVzZWQgdG8gbWFrZSBhc3luYyBjYWxscyB3aXRoIGNvbmN1cnJlbmN5IGFuZCByZXRyeSBsb2dpYy5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgbWFraW5nIGNhbGxzIHRvIGFueSBraW5kIG9mIFwiZXhwZW5zaXZlXCIgZXh0ZXJuYWwgcmVzb3VyY2UsXG4gKiBiZSBpdCBiZWNhdXNlIGl0J3MgcmF0ZS1saW1pdGVkLCBzdWJqZWN0IHRvIG5ldHdvcmsgaXNzdWVzLCBldGMuXG4gKlxuICogQ29uY3VycmVudCBjYWxscyBhcmUgbGltaXRlZCBieSB0aGUgYG1heENvbmN1cnJlbmN5YCBwYXJhbWV0ZXIsIHdoaWNoIGRlZmF1bHRzXG4gKiB0byBgSW5maW5pdHlgLiBUaGlzIG1lYW5zIHRoYXQgYnkgZGVmYXVsdCwgYWxsIGNhbGxzIHdpbGwgYmUgbWFkZSBpbiBwYXJhbGxlbC5cbiAqXG4gKiBSZXRyaWVzIGFyZSBsaW1pdGVkIGJ5IHRoZSBgbWF4UmV0cmllc2AgcGFyYW1ldGVyLCB3aGljaCBkZWZhdWx0cyB0byA1LiBUaGlzXG4gKiBtZWFucyB0aGF0IGJ5IGRlZmF1bHQsIGVhY2ggY2FsbCB3aWxsIGJlIHJldHJpZWQgdXAgdG8gNSB0aW1lcywgd2l0aCBhblxuICogZXhwb25lbnRpYWwgYmFja29mZiBiZXR3ZWVuIGVhY2ggYXR0ZW1wdC5cbiAqL1xuZXhwb3J0IGNsYXNzIEFzeW5jQ2FsbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4Q29uY3VycmVuY3lcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4UmV0cmllc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJxdWV1ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkZhaWxlZFJlc3BvbnNlSG9va1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjdXN0b21GZXRjaFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1heENvbmN1cnJlbmN5ID0gcGFyYW1zLm1heENvbmN1cnJlbmN5ID8/IEluZmluaXR5O1xuICAgICAgICB0aGlzLm1heFJldHJpZXMgPSBwYXJhbXMubWF4UmV0cmllcyA/PyA0O1xuICAgICAgICBpZiAoXCJkZWZhdWx0XCIgaW4gUFF1ZXVlTW9kKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IG5ldyBQUXVldWVNb2QuZGVmYXVsdCh7XG4gICAgICAgICAgICAgICAgY29uY3VycmVuY3k6IHRoaXMubWF4Q29uY3VycmVuY3ksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICB0aGlzLnF1ZXVlID0gbmV3IFBRdWV1ZU1vZCh7IGNvbmN1cnJlbmN5OiB0aGlzLm1heENvbmN1cnJlbmN5IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25GYWlsZWRSZXNwb25zZUhvb2sgPSBwYXJhbXM/Lm9uRmFpbGVkUmVzcG9uc2VIb29rO1xuICAgICAgICB0aGlzLmN1c3RvbUZldGNoID0gcGFyYW1zLmZldGNoO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNhbGwoY2FsbGFibGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3Qgb25GYWlsZWRSZXNwb25zZUhvb2sgPSB0aGlzLm9uRmFpbGVkUmVzcG9uc2VIb29rO1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZS5hZGQoKCkgPT4gcFJldHJ5KCgpID0+IGNhbGxhYmxlKC4uLmFyZ3MpLmNhdGNoKGFzeW5jIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVzcG9uc2UoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYXdhaXQgSFRUUEVycm9yLmZyb21SZXNwb25zZShlcnJvciwge1xuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlUmVzcG9uc2U6ICEhb25GYWlsZWRSZXNwb25zZUhvb2ssXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwge1xuICAgICAgICAgICAgYXN5bmMgb25GYWlsZWRBdHRlbXB0KGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIkNhbmNlbFwiKSB8fFxuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJUaW1lb3V0RXJyb3JcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiQWJvcnRFcnJvclwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3I/LmNvZGUgPT09IFwiRUNPTk5BQk9SVEVEXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEhUVFBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoU1RBVFVTX05PX1JFVFJZLmluY2x1ZGVzKGVycm9yLnN0YXR1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFNUQVRVU19JR05PUkUuaW5jbHVkZXMoZXJyb3Iuc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbkZhaWxlZFJlc3BvbnNlSG9vayAmJiBlcnJvci5yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgb25GYWlsZWRSZXNwb25zZUhvb2soZXJyb3IucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIElmIG5lZWRlZCB3ZSBjYW4gY2hhbmdlIHNvbWUgb2YgdGhlIGRlZmF1bHRzIGhlcmUsXG4gICAgICAgICAgICAvLyBidXQgdGhleSdyZSBxdWl0ZSBzZW5zaWJsZS5cbiAgICAgICAgICAgIHJldHJpZXM6IHRoaXMubWF4UmV0cmllcyxcbiAgICAgICAgICAgIHJhbmRvbWl6ZTogdHJ1ZSxcbiAgICAgICAgfSksIHsgdGhyb3dPblRpbWVvdXQ6IHRydWUgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY2FsbFdpdGhPcHRpb25zKG9wdGlvbnMsIGNhbGxhYmxlLCAuLi5hcmdzKSB7XG4gICAgICAgIC8vIE5vdGUgdGhpcyBkb2Vzbid0IGNhbmNlbCB0aGUgdW5kZXJseWluZyByZXF1ZXN0LFxuICAgICAgICAvLyB3aGVuIGF2YWlsYWJsZSBwcmVmZXIgdG8gdXNlIHRoZSBzaWduYWwgb3B0aW9uIG9mIHRoZSB1bmRlcmx5aW5nIGNhbGxcbiAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGwoY2FsbGFibGUsIC4uLmFyZ3MpLFxuICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWw/LmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQWJvcnRFcnJvclwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbChjYWxsYWJsZSwgLi4uYXJncyk7XG4gICAgfVxuICAgIGZldGNoKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgZmV0Y2hGbiA9IHRoaXMuY3VzdG9tRmV0Y2ggPz8gZmV0Y2g7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwoKCkgPT4gZmV0Y2hGbiguLi5hcmdzKS50aGVuKChyZXMpID0+IChyZXMub2sgPyByZXMgOiBQcm9taXNlLnJlamVjdChyZXMpKSkpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/@langchain+langgraph-sdk@0.0.8/node_modules/@langchain/langgraph-sdk/dist/utils/async_caller.mjs\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/@langchain+langgraph-sdk@0.0.8/node_modules/@langchain/langgraph-sdk/dist/utils/stream.mjs":
/*!************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@langchain+langgraph-sdk@0.0.8/node_modules/@langchain/langgraph-sdk/dist/utils/stream.mjs ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IterableReadableStream: () => (/* binding */ IterableReadableStream)\n/* harmony export */ });\n/*\n * Support async iterator syntax for ReadableStreams in all environments.\n * Source: https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nclass IterableReadableStream extends ReadableStream {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"reader\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    ensureReader() {\n        if (!this.reader) {\n            this.reader = this.getReader();\n        }\n    }\n    async next() {\n        this.ensureReader();\n        try {\n            const result = await this.reader.read();\n            if (result.done) {\n                this.reader.releaseLock(); // release lock when stream becomes closed\n                return {\n                    done: true,\n                    value: undefined,\n                };\n            }\n            else {\n                return {\n                    done: false,\n                    value: result.value,\n                };\n            }\n        }\n        catch (e) {\n            this.reader.releaseLock(); // release lock when stream becomes errored\n            throw e;\n        }\n    }\n    async return() {\n        this.ensureReader();\n        // If wrapped in a Node stream, cancel is already called.\n        if (this.locked) {\n            const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n            this.reader.releaseLock(); // release lock first\n            await cancelPromise; // now await it\n        }\n        return { done: true, value: undefined };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async throw(e) {\n        this.ensureReader();\n        if (this.locked) {\n            const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n            this.reader.releaseLock(); // release lock first\n            await cancelPromise; // now await it\n        }\n        throw e;\n    }\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n    static fromReadableStream(stream) {\n        // From https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams#reading_the_stream\n        const reader = stream.getReader();\n        return new IterableReadableStream({\n            start(controller) {\n                return pump();\n                function pump() {\n                    return reader.read().then(({ done, value }) => {\n                        // When no more data needs to be consumed, close the stream\n                        if (done) {\n                            controller.close();\n                            return;\n                        }\n                        // Enqueue the next data chunk into our target stream\n                        controller.enqueue(value);\n                        return pump();\n                    });\n                }\n            },\n            cancel() {\n                reader.releaseLock();\n            },\n        });\n    }\n    static fromAsyncGenerator(generator) {\n        return new IterableReadableStream({\n            async pull(controller) {\n                const { value, done } = await generator.next();\n                // When no more data needs to be consumed, close the stream\n                if (done) {\n                    controller.close();\n                }\n                // Fix: `else if (value)` will hang the streaming when nullish value (e.g. empty string) is pulled\n                controller.enqueue(value);\n            },\n            async cancel(reason) {\n                await generator.return(reason);\n            },\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BsYW5nY2hhaW4rbGFuZ2dyYXBoLXNka0AwLjAuOC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvdXRpbHMvc3RyZWFtLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsdUNBQXVDO0FBQ3ZDLGlDQUFpQztBQUNqQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELHVDQUF1QztBQUN2QyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aXRoLWxhbmdncmFwaC8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGgtc2RrQDAuMC44L25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC1zZGsvZGlzdC91dGlscy9zdHJlYW0ubWpzP2VkMzAiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIFN1cHBvcnQgYXN5bmMgaXRlcmF0b3Igc3ludGF4IGZvciBSZWFkYWJsZVN0cmVhbXMgaW4gYWxsIGVudmlyb25tZW50cy5cbiAqIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL01hdHRpYXNCdWVsZW5zL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3B1bGwvMTIyI2lzc3VlY29tbWVudC0xNjI3MzU0NDkwXG4gKi9cbmV4cG9ydCBjbGFzcyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtIGV4dGVuZHMgUmVhZGFibGVTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWFkZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW5zdXJlUmVhZGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMucmVhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRlciA9IHRoaXMuZ2V0UmVhZGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbmV4dCgpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVSZWFkZXIoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZGVyLnJlbGVhc2VMb2NrKCk7IC8vIHJlbGVhc2UgbG9jayB3aGVuIHN0cmVhbSBiZWNvbWVzIGNsb3NlZFxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnJlbGVhc2VMb2NrKCk7IC8vIHJlbGVhc2UgbG9jayB3aGVuIHN0cmVhbSBiZWNvbWVzIGVycm9yZWRcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmV0dXJuKCkge1xuICAgICAgICB0aGlzLmVuc3VyZVJlYWRlcigpO1xuICAgICAgICAvLyBJZiB3cmFwcGVkIGluIGEgTm9kZSBzdHJlYW0sIGNhbmNlbCBpcyBhbHJlYWR5IGNhbGxlZC5cbiAgICAgICAgaWYgKHRoaXMubG9ja2VkKSB7XG4gICAgICAgICAgICBjb25zdCBjYW5jZWxQcm9taXNlID0gdGhpcy5yZWFkZXIuY2FuY2VsKCk7IC8vIGNhbmNlbCBmaXJzdCwgYnV0IGRvbid0IGF3YWl0IHlldFxuICAgICAgICAgICAgdGhpcy5yZWFkZXIucmVsZWFzZUxvY2soKTsgLy8gcmVsZWFzZSBsb2NrIGZpcnN0XG4gICAgICAgICAgICBhd2FpdCBjYW5jZWxQcm9taXNlOyAvLyBub3cgYXdhaXQgaXRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgYXN5bmMgdGhyb3coZSkge1xuICAgICAgICB0aGlzLmVuc3VyZVJlYWRlcigpO1xuICAgICAgICBpZiAodGhpcy5sb2NrZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbFByb21pc2UgPSB0aGlzLnJlYWRlci5jYW5jZWwoKTsgLy8gY2FuY2VsIGZpcnN0LCBidXQgZG9uJ3QgYXdhaXQgeWV0XG4gICAgICAgICAgICB0aGlzLnJlYWRlci5yZWxlYXNlTG9jaygpOyAvLyByZWxlYXNlIGxvY2sgZmlyc3RcbiAgICAgICAgICAgIGF3YWl0IGNhbmNlbFByb21pc2U7IC8vIG5vdyBhd2FpdCBpdFxuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVJlYWRhYmxlU3RyZWFtKHN0cmVhbSkge1xuICAgICAgICAvLyBGcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdHJlYW1zX0FQSS9Vc2luZ19yZWFkYWJsZV9zdHJlYW1zI3JlYWRpbmdfdGhlX3N0cmVhbVxuICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgIHJldHVybiBuZXcgSXRlcmFibGVSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1bXAoKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBwdW1wKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQoKS50aGVuKCh7IGRvbmUsIHZhbHVlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gbm8gbW9yZSBkYXRhIG5lZWRzIHRvIGJlIGNvbnN1bWVkLCBjbG9zZSB0aGUgc3RyZWFtXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnF1ZXVlIHRoZSBuZXh0IGRhdGEgY2h1bmsgaW50byBvdXIgdGFyZ2V0IHN0cmVhbVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwdW1wKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW5jZWwoKSB7XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Bc3luY0dlbmVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGdlbmVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBubyBtb3JlIGRhdGEgbmVlZHMgdG8gYmUgY29uc3VtZWQsIGNsb3NlIHRoZSBzdHJlYW1cbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZpeDogYGVsc2UgaWYgKHZhbHVlKWAgd2lsbCBoYW5nIHRoZSBzdHJlYW1pbmcgd2hlbiBudWxsaXNoIHZhbHVlIChlLmcuIGVtcHR5IHN0cmluZykgaXMgcHVsbGVkXG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc3luYyBjYW5jZWwocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZ2VuZXJhdG9yLnJldHVybihyZWFzb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/@langchain+langgraph-sdk@0.0.8/node_modules/@langchain/langgraph-sdk/dist/utils/stream.mjs\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/@langchain+langgraph-sdk@0.0.8/node_modules/@langchain/langgraph-sdk/index.js":
/*!***********************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@langchain+langgraph-sdk@0.0.8/node_modules/@langchain/langgraph-sdk/index.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Client: () => (/* reexport safe */ _dist_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Client)
/* harmony export */ });
/* harmony import */ var _dist_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.mjs */ "(ssr)/../node_modules/.pnpm/@langchain+langgraph-sdk@0.0.8/node_modules/@langchain/langgraph-sdk/dist/index.mjs");


/***/ })

};
;